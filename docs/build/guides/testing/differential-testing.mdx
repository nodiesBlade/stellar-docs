---
title: Differential Testing
hide_table_of_contents: true
description: Differential testing detects unintended changes.
sidebar_position: 4
---

Differential testing is the testing of two things to discover differences in their behavior.

The goal is to prove that the two things behave consistently, and that they do not diverge in behavior except for some expected differences. The assertions should be as broad as possible, broadly testing that all observable outcomes do not change, except for any expected changes.

This strategy is effective when building something new that should behave like something that already exists. That could be a new version of a contract that has unchanged behavior from it's previous version. Or it could be a refactor that expects no functional changes. Or it could be a reimplementation of the same interface.

This strategy can be used in the context of unit and integration tests, or in the context of fuzz tests as well.

:::tip

All contracts built with the Rust Soroban SDK have a form of differential testing built-in and enabled by default. See [Differential Testing with Test Snapshots].

:::

### Example

To experiment with writing a differential test, open a contract that you've deployed, or checkout an example from the [soroban-examples] repository and deploy it.

Assume the contract has been deployed, and a changes are being made to the contract and we need to check that other behavior in the contract hasn't changed compared to what is deployed.

Use the [stellar contract fetch] command to fetch the contract that's already deployed.

```console
$ stellar contract fetch --id C... --out-file contract.wasm
```

Write a test that runs the same logic for the deployed contract and the local contract, comparing the result. Assuming the [increment example] is in use, the test would look something like the following.

```rust
#![cfg(test)]
use crate::{IncrementContract, IncrementContractClient};
use soroban_sdk::{testutils::Events as _, Env};

mod deployed {
    soroban_sdk::contractimport!(file = "contract.wasm");
}

#[test]
fn differential_test() {
    let env = Env::default();
    assert_eq!(
        {
            let contract_id = env.register(deployed::WASM, ());
            let client = IncrementContractClient::new(&env, &contract_id);
            (
                // Return Values
                (
                    client.increment(),
                    client.increment(),
                    client.increment(),
                ),
                // Events
                env.events.all(),
            )
        },
        {
            let contract_id = env.register(IncrementContract, ());
            let client = IncrementContractClient::new(&env, &contract_id);
            (
                // Return Values
                (
                    client.increment(),
                    client.increment(),
                    client.increment(),
                ),
                // Events
                env.events.all(),
            )
        },
    );
}
```

This test uses the same patterns used in [integration tests]:
1. Create an environment, the `Env`.
2. Import the Wasm contract to compare with.
3. Register the local contract to be tested.
4. Invoke functions using a client.
5. Assert equality.

::: info

Depending on the test complexity it can be desirable to use an independent `Env` for testing the deployed vs local, however it is only possible to compare host values, like `String`, `Bytes`, `Vec`, `Map`, if they've been created using the same `Env`.

:::

[Getting Started]: ../../smart-contracts/getting-started
[soroban-examples]: https://github.com/stellar/soroban-examples
[Differential Testing with Test Snapshots]: differential-testing-with-snapshots
[stellar contract fetch]: ../../tools/developer-tools/cli/stellar-cli#stellar-contract-fetch
[integration tests]: integration-tests.mdx
